// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package dbsqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type AssignInstructionsToWalletParams struct {
	WalletID    int32 `json:"wallet_id"`
	SignatureID int32 `json:"signature_id"`
}

const GetAddressesFromAddresses = `-- name: GetAddressesFromAddresses :many
SELECT value, id FROM address WHERE value = ANY($1::VARCHAR[])
`

type GetAddressesFromAddressesRow struct {
	Value string `json:"value"`
	ID    int32  `json:"id"`
}

func (q *Queries) GetAddressesFromAddresses(ctx context.Context, dollar_1 []string) ([]*GetAddressesFromAddressesRow, error) {
	rows, err := q.db.Query(ctx, GetAddressesFromAddresses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAddressesFromAddressesRow
	for rows.Next() {
		var i GetAddressesFromAddressesRow
		if err := rows.Scan(&i.Value, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAssociatedAccountsForWallet = `-- name: GetAssociatedAccountsForWallet :many
SELECT
    address.value AS address, signature.value as last_signature
FROM
    associated_account
INNER JOIN
    address ON address.id = associated_account.address_id
LEFT JOIN
    signature ON signature.id = associated_account.signature_id
WHERE
    associated_account.wallet_id = $1
`

type GetAssociatedAccountsForWalletRow struct {
	Address       string      `json:"address"`
	LastSignature pgtype.Text `json:"last_signature"`
}

func (q *Queries) GetAssociatedAccountsForWallet(ctx context.Context, walletID int32) ([]*GetAssociatedAccountsForWalletRow, error) {
	rows, err := q.db.Query(ctx, GetAssociatedAccountsForWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAssociatedAccountsForWalletRow
	for rows.Next() {
		var i GetAssociatedAccountsForWalletRow
		if err := rows.Scan(&i.Address, &i.LastSignature); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetLatestSyncWalletRequest = `-- name: GetLatestSyncWalletRequest :one
SELECT
	sync_wallet_request.wallet_id,
	address.value AS address,
	signature.value AS last_signature
FROM
	sync_wallet_request
INNER JOIN
	wallet ON wallet.id = sync_wallet_request.wallet_id
INNER JOIN
	address ON address.id = wallet.address_id
LEFT JOIN
	signature ON signature.id = wallet.last_signature_id
WHERE
	sync_wallet_request.status = 'queued'
ORDER BY
	sync_wallet_request.created_at ASC
LIMIT
	1
`

type GetLatestSyncWalletRequestRow struct {
	WalletID      int32       `json:"wallet_id"`
	Address       string      `json:"address"`
	LastSignature pgtype.Text `json:"last_signature"`
}

func (q *Queries) GetLatestSyncWalletRequest(ctx context.Context) (*GetLatestSyncWalletRequestRow, error) {
	row := q.db.QueryRow(ctx, GetLatestSyncWalletRequest)
	var i GetLatestSyncWalletRequestRow
	err := row.Scan(&i.WalletID, &i.Address, &i.LastSignature)
	return &i, err
}

const GetTransactionsFromSignatures = `-- name: GetTransactionsFromSignatures :many
SELECT
    (
        SELECT coalesce(json_agg(agg), '[]') FROM (
    		SELECT
    			address.value as program_address,
    			instruction.data, (
                    SELECT coalesce(json_agg(agg), '[]') FROM (
                        SELECT
                            address.id,
                            address.value,
                            array_position(instructions.accounts_ids, id) AS ord
                        FROM
                            address
                        WHERE
                            address.id = ANY(instruction.accounts_ids)
                        ORDER BY
                            ord ASC
         			) AS agg
          		) AS accounts,
    			(
    				SELECT coalesce(json_agg(agg), '[]') FROM (
    					SELECT
    						address.value AS program_address,
    						inner_instruction.data, (
                 			    SELECT coalesce(json_agg(agg), '[]') FROM (
                                    SELECT
                                        address.id,
                                        address.value,
                                        array_position(inner_instruction.accounts_ids, id) AS ord
                                    FROM
                                        address
                                    WHERE
                                        address.id = ANY(inner_instruction.accounts_ids)
                                    ORDER BY
                                        ord ASC
                                ) AS agg
                            ) AS accounts
    					FROM
    						inner_instruction
    					INNER JOIN
    						address ON address.id = inner_instruction.program_account_id
    					WHERE
    						inner_instruction.signature_id = instruction.signature_id
    						AND inner_instruction.ix_index = instruction.index
    					ORDER BY
    						inner_instruction.index ASC
    				) AS agg
    			) AS inner_ixs
    		FROM
    			instruction
    		INNER JOIN
    			address ON address.id = instruction.program_account_id
    		WHERE
    			instruction.signature_id = signature.id
    		ORDER BY
    			instruction.index ASC
    	) AS agg
    ) AS ixs,
    transaction.logs,
    transaction.err,
    signature.value as signature,
    signature.id as signature_id
FROM
	signature
INNER JOIN
	transaction ON transaction.signature_id = signature.id
WHERE
	signature.value = ANY($1::VARCHAR[])
`

type GetTransactionsFromSignaturesRow struct {
	Ixs         interface{} `json:"ixs"`
	Logs        []string    `json:"logs"`
	Err         bool        `json:"err"`
	Signature   string      `json:"signature"`
	SignatureID int32       `json:"signature_id"`
}

func (q *Queries) GetTransactionsFromSignatures(ctx context.Context, dollar_1 []string) ([]*GetTransactionsFromSignaturesRow, error) {
	rows, err := q.db.Query(ctx, GetTransactionsFromSignatures, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsFromSignaturesRow
	for rows.Next() {
		var i GetTransactionsFromSignaturesRow
		if err := rows.Scan(
			&i.Ixs,
			&i.Logs,
			&i.Err,
			&i.Signature,
			&i.SignatureID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTransactionsWithDuplicateTimestamps = `-- name: GetTransactionsWithDuplicateTimestamps :many
SELECT
    t1.id,
    t1.slot,
    signature.value as signature
FROM
    transaction t1
INNER JOIN
    signature ON signature.id = t1.signature_id
WHERE
    EXISTS(
    	SELECT
    		1
    	FROM
    		transaction t2
    	WHERE
    		t1.id != t2.id AND t1.timestamp = t2.timestamp AND t1.slot = t2.slot AND t1.block_index IS NULL AND t2.block_index IS NULL
    )
    AND t1.id > $1
ORDER BY
    t1.id ASC
LIMIT
    500
`

type GetTransactionsWithDuplicateTimestampsRow struct {
	ID        int32  `json:"id"`
	Slot      int64  `json:"slot"`
	Signature string `json:"signature"`
}

func (q *Queries) GetTransactionsWithDuplicateTimestamps(ctx context.Context, startID int32) ([]*GetTransactionsWithDuplicateTimestampsRow, error) {
	rows, err := q.db.Query(ctx, GetTransactionsWithDuplicateTimestamps, startID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTransactionsWithDuplicateTimestampsRow
	for rows.Next() {
		var i GetTransactionsWithDuplicateTimestampsRow
		if err := rows.Scan(&i.ID, &i.Slot, &i.Signature); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const InsertAddresses = `-- name: InsertAddresses :many
INSERT INTO address (value) (SELECT unnest FROM unnest($1::VARCHAR[])) ON CONFLICT (value) DO NOTHING RETURNING value, id
`

type InsertAddressesRow struct {
	Value string `json:"value"`
	ID    int32  `json:"id"`
}

func (q *Queries) InsertAddresses(ctx context.Context, dollar_1 []string) ([]*InsertAddressesRow, error) {
	rows, err := q.db.Query(ctx, InsertAddresses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*InsertAddressesRow
	for rows.Next() {
		var i InsertAddressesRow
		if err := rows.Scan(&i.Value, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertAssociatedAccountsParams struct {
	WalletID  int32                 `json:"wallet_id"`
	AddressID int32                 `json:"address_id"`
	Type      AssociatedAccountType `json:"type"`
}

type InsertInnerInstructionsParams struct {
	SignatureID      int32   `json:"signature_id"`
	IxIndex          int16   `json:"ix_index"`
	Index            int16   `json:"index"`
	ProgramAccountID int32   `json:"program_account_id"`
	AccountsIds      []int32 `json:"accounts_ids"`
	Data             string  `json:"data"`
}

type InsertInstructionEventsParams struct {
	SignatureID int32     `json:"signature_id"`
	IxIndex     int16     `json:"ix_index"`
	Index       int16     `json:"index"`
	Type        EventType `json:"type"`
	Data        []byte    `json:"data"`
}

type InsertInstructionsParams struct {
	SignatureID      int32   `json:"signature_id"`
	Index            int16   `json:"index"`
	ProgramAccountID int32   `json:"program_account_id"`
	AccountsIds      []int32 `json:"accounts_ids"`
	Data             string  `json:"data"`
}

const InsertSignatures = `-- name: InsertSignatures :many
INSERT INTO signature (value) (SELECT unnest FROM unnest($1::VARCHAR[])) RETURNING id, value
`

type InsertSignaturesRow struct {
	ID    int32  `json:"id"`
	Value string `json:"value"`
}

func (q *Queries) InsertSignatures(ctx context.Context, dollar_1 []string) ([]*InsertSignaturesRow, error) {
	rows, err := q.db.Query(ctx, InsertSignatures, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*InsertSignaturesRow
	for rows.Next() {
		var i InsertSignaturesRow
		if err := rows.Scan(&i.ID, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type InsertTransactionsParams struct {
	SignatureID           int32              `json:"signature_id"`
	AccountsIds           []int32            `json:"accounts_ids"`
	Timestamp             pgtype.Timestamptz `json:"timestamp"`
	TimestampGranularized pgtype.Timestamptz `json:"timestamp_granularized"`
	Slot                  int64              `json:"slot"`
	Logs                  []string           `json:"logs"`
	Err                   bool               `json:"err"`
	Fee                   int64              `json:"fee"`
}

const UpdateAssociatedAccountLastSignature = `-- name: UpdateAssociatedAccountLastSignature :exec
UPDATE associated_account SET
    last_signature_id = (SELECT signature.id FROM signature WHERE signature.value = $1)
WHERE
    address_id = (SELECT address.id FROM address WHERE address.value = $2)
    AND wallet_id = $3
`

type UpdateAssociatedAccountLastSignatureParams struct {
	LastSignature            string `json:"last_signature"`
	AssociatedAccountAddress string `json:"associated_account_address"`
	WalletID                 int32  `json:"wallet_id"`
}

func (q *Queries) UpdateAssociatedAccountLastSignature(ctx context.Context, arg *UpdateAssociatedAccountLastSignatureParams) error {
	_, err := q.db.Exec(ctx, UpdateAssociatedAccountLastSignature, arg.LastSignature, arg.AssociatedAccountAddress, arg.WalletID)
	return err
}

const UpdateTransactionsBlockIndexes = `-- name: UpdateTransactionsBlockIndexes :exec
UPDATE transaction SET block_index = v.bi FROM (
    SELECT
        unnest($1::INTEGER[]) as txid,
        unnest($2::INTEGER[]) as bi
) AS v WHERE transaction.id = v.txid
`

type UpdateTransactionsBlockIndexesParams struct {
	TransactionsIds []int32 `json:"transactions_ids"`
	BlockIndexes    []int32 `json:"block_indexes"`
}

func (q *Queries) UpdateTransactionsBlockIndexes(ctx context.Context, arg *UpdateTransactionsBlockIndexesParams) error {
	_, err := q.db.Exec(ctx, UpdateTransactionsBlockIndexes, arg.TransactionsIds, arg.BlockIndexes)
	return err
}

const UpdateWalletAggregateCounts = `-- name: UpdateWalletAggregateCounts :exec
UPDATE wallet SET
    signatures = $1,
    associated_accounts = $2
WHERE id = $3
`

type UpdateWalletAggregateCountsParams struct {
	SignaturesCount         int32 `json:"signatures_count"`
	AssociatedAccountsCount int32 `json:"associated_accounts_count"`
	WalletID                int32 `json:"wallet_id"`
}

func (q *Queries) UpdateWalletAggregateCounts(ctx context.Context, arg *UpdateWalletAggregateCountsParams) error {
	_, err := q.db.Exec(ctx, UpdateWalletAggregateCounts, arg.SignaturesCount, arg.AssociatedAccountsCount, arg.WalletID)
	return err
}

const UpdateWalletAggregateCountsAndLastSignature = `-- name: UpdateWalletAggregateCountsAndLastSignature :exec
UPDATE wallet SET
    signatures = signatures + $1,
    associated_accounts = associated_accounts + $2,
    last_signature_id = (SELECT signature.id FROM signature WHERE signature.value = $3)
WHERE wallet.id = $4
`

type UpdateWalletAggregateCountsAndLastSignatureParams struct {
	SignaturesCount         int32  `json:"signatures_count"`
	AssociatedAccountsCount int32  `json:"associated_accounts_count"`
	LastSignature           string `json:"last_signature"`
	WalletID                int32  `json:"wallet_id"`
}

func (q *Queries) UpdateWalletAggregateCountsAndLastSignature(ctx context.Context, arg *UpdateWalletAggregateCountsAndLastSignatureParams) error {
	_, err := q.db.Exec(ctx, UpdateWalletAggregateCountsAndLastSignature,
		arg.SignaturesCount,
		arg.AssociatedAccountsCount,
		arg.LastSignature,
		arg.WalletID,
	)
	return err
}
