// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: copyfrom.go

package dbsqlc

import (
	"context"
)

// iteratorForAssignInstructionsToWallet implements pgx.CopyFromSource.
type iteratorForAssignInstructionsToWallet struct {
	rows                 []*AssignInstructionsToWalletParams
	skippedFirstNextCall bool
}

func (r *iteratorForAssignInstructionsToWallet) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForAssignInstructionsToWallet) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].WalletID,
		r.rows[0].SignatureID,
	}, nil
}

func (r iteratorForAssignInstructionsToWallet) Err() error {
	return nil
}

func (q *Queries) AssignInstructionsToWallet(ctx context.Context, arg []*AssignInstructionsToWalletParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"wallet_to_signature"}, []string{"wallet_id", "signature_id"}, &iteratorForAssignInstructionsToWallet{rows: arg})
}

// iteratorForInsertAssociatedAccounts implements pgx.CopyFromSource.
type iteratorForInsertAssociatedAccounts struct {
	rows                 []*InsertAssociatedAccountsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertAssociatedAccounts) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertAssociatedAccounts) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].WalletID,
		r.rows[0].AddressID,
		r.rows[0].Type,
	}, nil
}

func (r iteratorForInsertAssociatedAccounts) Err() error {
	return nil
}

func (q *Queries) InsertAssociatedAccounts(ctx context.Context, arg []*InsertAssociatedAccountsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"associated_account"}, []string{"wallet_id", "address_id", "type"}, &iteratorForInsertAssociatedAccounts{rows: arg})
}

// iteratorForInsertInnerInstructions implements pgx.CopyFromSource.
type iteratorForInsertInnerInstructions struct {
	rows                 []*InsertInnerInstructionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertInnerInstructions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertInnerInstructions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SignatureID,
		r.rows[0].IxIndex,
		r.rows[0].Index,
		r.rows[0].ProgramAccountID,
		r.rows[0].AccountsIds,
		r.rows[0].Data,
	}, nil
}

func (r iteratorForInsertInnerInstructions) Err() error {
	return nil
}

func (q *Queries) InsertInnerInstructions(ctx context.Context, arg []*InsertInnerInstructionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"inner_instruction"}, []string{"signature_id", "ix_index", "index", "program_account_id", "accounts_ids", "data"}, &iteratorForInsertInnerInstructions{rows: arg})
}

// iteratorForInsertInstructionEvents implements pgx.CopyFromSource.
type iteratorForInsertInstructionEvents struct {
	rows                 []*InsertInstructionEventsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertInstructionEvents) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertInstructionEvents) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SignatureID,
		r.rows[0].IxIndex,
		r.rows[0].Index,
		r.rows[0].Type,
		r.rows[0].Data,
	}, nil
}

func (r iteratorForInsertInstructionEvents) Err() error {
	return nil
}

func (q *Queries) InsertInstructionEvents(ctx context.Context, arg []*InsertInstructionEventsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"instruction_event"}, []string{"signature_id", "ix_index", "index", "type", "data"}, &iteratorForInsertInstructionEvents{rows: arg})
}

// iteratorForInsertInstructions implements pgx.CopyFromSource.
type iteratorForInsertInstructions struct {
	rows                 []*InsertInstructionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertInstructions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertInstructions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SignatureID,
		r.rows[0].Index,
		r.rows[0].ProgramAccountID,
		r.rows[0].AccountsIds,
		r.rows[0].Data,
	}, nil
}

func (r iteratorForInsertInstructions) Err() error {
	return nil
}

func (q *Queries) InsertInstructions(ctx context.Context, arg []*InsertInstructionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"instruction"}, []string{"signature_id", "index", "program_account_id", "accounts_ids", "data"}, &iteratorForInsertInstructions{rows: arg})
}

// iteratorForInsertTransactions implements pgx.CopyFromSource.
type iteratorForInsertTransactions struct {
	rows                 []*InsertTransactionsParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertTransactions) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertTransactions) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].SignatureID,
		r.rows[0].AccountsIds,
		r.rows[0].Timestamp,
		r.rows[0].TimestampGranularized,
		r.rows[0].Slot,
		r.rows[0].Logs,
		r.rows[0].Err,
		r.rows[0].Fee,
	}, nil
}

func (r iteratorForInsertTransactions) Err() error {
	return nil
}

func (q *Queries) InsertTransactions(ctx context.Context, arg []*InsertTransactionsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"transaction"}, []string{"signature_id", "accounts_ids", "timestamp", "timestamp_granularized", "slot", "logs", "err", "fee"}, &iteratorForInsertTransactions{rows: arg})
}
